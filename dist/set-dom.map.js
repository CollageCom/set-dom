{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/index.js",
    "src/parse-html.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require(2)\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar ELEMENT_TYPE = window.Node.ELEMENT_NODE\nvar DOCUMENT_TYPE = window.Node.DOCUMENT_NODE\nvar MOUNT_EVENT = document.createEvent('Event')\nvar DISMOUNT_EVENT = document.createEvent('Event')\nvar WRITABLE = { writable: true }\nMOUNT_EVENT.initEvent('mount', false, false)\nDISMOUNT_EVENT.initEvent('dismount', false, false)\nObject.defineProperty(MOUNT_EVENT, 'target', WRITABLE)\nObject.defineProperty(MOUNT_EVENT, 'srcElement', WRITABLE)\nObject.defineProperty(DISMOUNT_EVENT, 'target', WRITABLE)\nObject.defineProperty(DISMOUNT_EVENT, 'srcElement', WRITABLE)\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} prev - The html entity to update.\n * @param {String|Node} next - The updated html(entity).\n */\nfunction setDOM (prev, next) {\n  // Ensure a realish dom node is provided.\n  assert(prev && prev.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (prev.nodeType === DOCUMENT_TYPE) prev = prev.documentElement\n\n  // If a string was provided we will parse it as dom.\n  if (typeof next === 'string') next = parseHTML(next, prev.nodeName)\n\n  // Update the node.\n  setNode(prev, next)\n\n  // Trigger mount events on initial set.\n  if (!prev[NODE_MOUNTED]) {\n    prev[NODE_MOUNTED] = true\n    dispatch(prev, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} prev - The previous HTMLNode.\n * @param {Node} next - The updated HTMLNode.\n */\nfunction setNode (prev, next) {\n  if (prev.nodeType === next.nodeType) {\n    // Handle regular element node updates.\n    if (prev.nodeType === ELEMENT_TYPE) {\n      // Ignore elements if their checksum matches.\n      if (getCheckSum(prev) === getCheckSum(next)) return\n      // Ignore elements that explicity choose not to be diffed.\n      if (isIgnored(prev) && isIgnored(next)) return\n\n      // Update all children (and subchildren).\n      setChildNodes(prev, next)\n\n      // Update the elements attributes / tagName.\n      if (prev.nodeName === next.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(prev, prev.attributes, next.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = next.cloneNode()\n        // Copy over all existing children from the original node.\n        while (prev.firstChild) newPrev.appendChild(prev.firstChild)\n        // Replace the original node with the new one with the right tag.\n        prev.parentNode.replaceChild(newPrev, prev)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (prev.nodeValue !== next.nodeValue) {\n        prev.nodeValue = next.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    dispatch(prev, DISMOUNT_EVENT)\n    prev.parentNode.replaceChild(next, prev)\n    dispatch(next, MOUNT_EVENT)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {Node} parent - The current parentNode being updated.\n * @param {NamedNodeMap} prev - The previous attributes.\n * @param {NamedNodeMap} next - The updated attributes.\n */\nfunction setAttributes (parent, prev, next) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = prev.length; i--;) {\n    a = prev[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = next.getNamedItemNS(ns, name)\n    if (!b) prev.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = next.length; i--;) {\n    a = next[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = prev.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      next.removeNamedItemNS(ns, name)\n      prev.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} prevParent - The existing parent node.\n * @param {Node} nextParent - The new parent node.\n */\nfunction setChildNodes (prevParent, nextParent) {\n  var prevKey, nextKey, diffPrev, diffNext, cached\n  var prevNode = prevParent.firstChild\n  var nextNode = nextParent.firstChild\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  var extra = 0\n  var prevKeys\n  while (prevNode) {\n    extra++\n    prevKey = getKey(prevNode)\n    if (prevKey) {\n      if (!prevKeys) prevKeys = {}\n      prevKeys[prevKey] = prevNode\n    }\n    prevNode = prevNode.nextSibling\n  }\n\n  // Loop over new nodes and perform updates.\n  prevNode = prevParent.firstChild\n  while (nextNode) {\n    diffNext = nextNode\n\n    if (prevKeys && (nextKey = getKey(nextNode)) && (cached = prevKeys[nextKey])) {\n      // If we have a key and it existed before we move the previous node to the new position and diff it.\n      prevParent.insertBefore(cached, prevNode)\n      setNode(cached, diffNext)\n    } else if (prevNode && !getKey(prevNode)) {\n      // If there was no keys on either side we simply diff the nodes.\n      diffPrev = prevNode\n      prevNode = prevNode.nextSibling\n      setNode(diffPrev, diffNext)\n    } else {\n      // Otherwise we append or insert the new node at the proper position.\n      prevParent.insertBefore(diffNext, prevNode)\n      dispatch(diffNext, MOUNT_EVENT)\n    }\n\n    extra--\n    nextNode = nextNode.nextSibling\n  }\n\n  // If we have any remaining remove them from the end.\n  while (extra > 0) {\n    extra--\n    prevParent.removeChild(dispatch(prevParent.lastChild, DISMOUNT_EVENT))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {String}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {String|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {Boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n */\nfunction dispatch (node, ev) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    ev.target = ev.srcElement = node\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, ev).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {String} msg - the error message on failure.\n * @throws Error\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n",
    "'use strict'\n\nvar parser = window.DOMParser && new window.DOMParser()\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testCode = '<i></i>'\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsXHTMLType = false\n\n// Check if browser supports text/html DOMParser\ntry {\n  /* istanbul ignore next: Fails in older browsers */\n  if (parser.parseFromString(testCode, htmlType)) supportsHTMLType = true\n} catch (err) {}\n\ntry {\n  /* istanbul ignore next: Only used in ie9 */\n  if (!supportsHTMLType && parser.parseFromString(testCode, xhtmlType)) supportsXHTMLType = true\n} catch (err) {}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browser and IE9).\n */\nmodule.exports = supportsHTMLType\n  ? function parseHTML (markup, rootName) {\n    var doc = parser.parseFromString(markup, htmlType)\n    return rootName === documentRootName\n      ? doc.documentElement\n      : doc.body.firstChild\n  }\n  /* istanbul ignore next: Only used in older browsers */\n  : function parseHTML (markup, rootName) {\n    var isRoot = rootName === documentRootName\n\n    // Special case for ie9 (documentElement.innerHTML not supported).\n    if (supportsXHTMLType && isRoot) {\n      return parser.parseFromString(markup, xhtmlType).documentElement\n    }\n\n    // Fallback to innerHTML for other older browsers.\n    var doc = document.implementation.createHTMLDocument('')\n    if (isRoot) {\n      doc.documentElement.innerHTML = markup\n      return doc.documentElement\n    } else {\n      doc.body.innerHTML = markup\n      return doc.body.firstChild\n    }\n  }\n"
  ]
}