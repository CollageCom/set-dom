{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/index.js",
    "src/parse-html.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict'\n\nvar parseHTML = require(2)\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_INDEX = KEY_PREFIX + 'index'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar ELEMENT_TYPE = window.Node.ELEMENT_NODE\nvar DOCUMENT_TYPE = window.Node.DOCUMENT_NODE\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\n\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} prev - The html entity to update.\n * @param {String|Node} next - The updated html(entity).\n */\nfunction setDOM (prev, next) {\n  // Ensure a realish dom node is provided.\n  assert(prev && prev.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (prev.nodeType === DOCUMENT_TYPE) prev = prev.documentElement\n\n  // If a string was provided we will parse it as dom.\n  if (typeof next === 'string') next = parseHTML(next, prev.nodeName)\n\n  // Update the node.\n  setNode(prev, next)\n\n  // Trigger mount events on initial set.\n  if (!prev[NODE_MOUNTED]) {\n    prev[NODE_MOUNTED] = true\n    mount(prev)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} prev - The previous HTMLNode.\n * @param {Node} next - The updated HTMLNode.\n */\nfunction setNode (prev, next) {\n  if (prev.nodeType === next.nodeType) {\n    // Handle regular element node updates.\n    if (prev.nodeType === ELEMENT_TYPE) {\n      // Ignore elements that explicity choose not to be diffed.\n      if (!(prev.attributes[setDOM.IGNORE] && next.attributes[setDOM.IGNORE])) {\n        // Update all children (and subchildren).\n        setChildNodes(prev, prev.childNodes, next.childNodes)\n\n        // Update the elements attributes / tagName.\n        if (prev.nodeName === next.nodeName) {\n          // If we have the same nodename then we can directly update the attributes.\n          setAttributes(prev, prev.attributes, next.attributes)\n        } else {\n          // Otherwise clone the new node to use as the existing node.\n          var newPrev = next.cloneNode()\n          // Copy over all existing children from the original node.\n          while (prev.firstChild) newPrev.appendChild(prev.firstChild)\n          // Replace the original node with the new one with the right tag.\n          prev.parentNode.replaceChild(newPrev, prev)\n        }\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (prev.nodeValue !== next.nodeValue) {\n        prev.nodeValue = next.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    dismount(prev)\n    prev.parentNode.replaceChild(next, prev)\n    mount(next)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {Node} parent - The current parentNode being updated.\n * @param {NamedNodeMap} prev - The previous attributes.\n * @param {NamedNodeMap} next - The updated attributes.\n */\nfunction setAttributes (parent, prev, next) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = prev.length; i--;) {\n    a = prev[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = next.getNamedItemNS(ns, name)\n    if (!b) prev.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = next.length; i--;) {\n    a = next[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = prev.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      next.removeNamedItemNS(ns, name)\n      prev.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of childNodes to match another.\n *\n * @param {Node} parent - The current parentNode being updated.\n * @param {NodeList} prevChildNodes - The previous children.\n * @param {NodeList} nextChildNodes - The updated children.\n */\nfunction setChildNodes (parent, prevChildNodes, nextChildNodes) {\n  var key, a, b, newPosition, nextEl\n\n  // Convert nodelists into a usuable map.\n  var prev = keyNodes(prevChildNodes)\n  var next = keyNodes(nextChildNodes)\n\n  // Remove old nodes.\n  for (key in prev) {\n    if (next[key]) continue\n    // Trigger custom dismount event.\n    dismount(prev[key])\n    // Remove child from dom.\n    parent.removeChild(prev[key])\n  }\n\n  // Set new nodes.\n  for (key in next) {\n    a = prev[key]\n    b = next[key]\n    // Extract the position of the new node.\n    newPosition = b[NODE_INDEX]\n\n    if (a) {\n      // Update an existing node.\n      setNode(a, b)\n      // Check if the node has moved in the tree.\n      if (a[NODE_INDEX] === newPosition) continue\n      // Get the current element at the new position.\n      /* istanbul ignore next */\n      nextEl = prevChildNodes[newPosition] || null // TODO: figure out if || null is needed.\n      // Check if the node has already been properly positioned.\n      if (nextEl === a) continue\n      // Reposition node.\n      parent.insertBefore(a, nextEl)\n    } else {\n      // Get the current element at the new position.\n      nextEl = prevChildNodes[newPosition] || null\n      // Append the new node at the correct position.\n      parent.insertBefore(b, nextEl)\n      // Trigger custom mounted event.\n      mount(b)\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Converts a nodelist into a keyed map.\n * This is used for diffing while keeping elements with 'data-key' or 'id' if possible.\n *\n * @param {NodeList} childNodes - The childNodes to convert.\n * @return {Object}\n */\nfunction keyNodes (childNodes) {\n  var result = {}\n  var len = childNodes.length\n  var el\n\n  for (var i = 0; i < len; i++) {\n    el = childNodes[i]\n    el[NODE_INDEX] = i\n    result[getKey(el) || i] = el\n  }\n\n  return result\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {String}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) key = KEY_PREFIX + key\n  return key && KEY_PREFIX + key\n}\n\n/**\n * Recursively trigger a mount event for a node and it's children.\n *\n * @param {Node} node - the initial node to be mounted.\n */\nfunction mount (node) {\n  // Trigger mount event for this element if it has a key.\n  if (getKey(node)) dispatch(node, 'mount')\n\n  // Mount all children.\n  var child = node.firstChild\n  while (child) {\n    mount(child)\n    child = child.nextSibling\n  }\n}\n\n/**\n * Recursively trigger a dismount event for a node and it's children.\n *\n * @param {Node} node - the initial node to be dismounted.\n */\nfunction dismount (node) {\n  // Dismount all children.\n  var child = node.firstChild\n  while (child) {\n    dismount(child)\n    child = child.nextSibling\n  }\n\n  // Trigger dismount event for this element if it has a key.\n  if (getKey(node)) dispatch(node, 'dismount')\n}\n\n/**\n * @private\n * @description\n * Create and dispatch a custom event.\n *\n * @param {Node} el - the node to dispatch the event for.\n * @param {String} type - the name of the event.\n */\nfunction dispatch (el, type) {\n  var e = document.createEvent('Event')\n  var prop = { value: el }\n  e.initEvent(type, false, false)\n  Object.defineProperty(e, 'target', prop)\n  Object.defineProperty(e, 'srcElement', prop)\n  el.dispatchEvent(e)\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {String} msg - the error message on failure.\n * @throws Error\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n",
    "'use strict'\n\nvar parser = new window.DOMParser()\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar supportsHTMLType = false\nvar supportsXHTMLType = false\n\n// Check if browser supports text/html DOMParser\ntry {\n  /* istanbul ignore next: Fails in older browsers */\n  if (parser.parseFromString('<i></i>', htmlType)) supportsHTMLType = true\n} catch (err) {}\n\ntry {\n  /* istanbul ignore next: Only used in ie9 */\n  if (parser.parseFromString('<i></i>', xhtmlType)) supportsXHTMLType = true\n} catch (err) {}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browser and IE9).\n */\nmodule.exports = supportsHTMLType\n  ? function parseHTML (markup, rootName) {\n    var doc = parser.parseFromString(markup, htmlType)\n    return rootName === 'HTML'\n      ? doc.documentElement\n      : doc.body.firstChild\n  }\n  /* istanbul ignore next: Only used in older browsers */\n  : function parseHTML (markup, rootName) {\n    var isRoot = rootName === 'HTML'\n\n    // Special case for ie9 (documentElement.innerHTML not supported).\n    if (supportsXHTMLType && isRoot) {\n      return parser.parseFromString(markup, xhtmlType).documentElement\n    }\n\n    var doc = document.implementation.createHTMLDocument('')\n    if (isRoot) {\n      doc.documentElement.innerHTML = markup\n      return doc.documentElement\n    } else {\n      doc.body.innerHTML = markup\n      return doc.body.firstChild\n    }\n  }\n"
  ]
}